<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>EPRA EER System (Offline, JS) - Auto-detect Columns</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
.sticky-th th { position: sticky; top: 0; background: #f8f9fa; z-index: 2; }
.mini { font-size:.85rem; color:#6c757d; }
.totals-row { font-weight:700; background:#f1f3f5; }
.small-input { max-width:160px; display:inline-block; }
.summary-box { background:#fff; padding:12px; border-radius:6px; box-shadow:0 0 6px rgba(0,0,0,0.03); }
</style>
</head>
<body class="p-4 bg-light">
<div class="container">
<h2 class="mb-4 text-center">EPRA Energy Efficiency Ratio (EER) — Fully Offline JS (Auto-detect)</h2>

<div class="row g-3 mb-3 align-items-end">
  <div class="col-md-6">
    <input type="file" id="fileInput" class="form-control" accept=".xls,.xlsx,.csv"/>
    <div class="mini mt-1">
      The script will try to auto-detect Facility, Energy, Production, Weather1 and Weather2 columns by header keywords (flexible order).
    </div>
  </div>
  <div class="col-md-6 d-flex gap-2">
    <button class="btn btn-primary" onclick="processExcel()">Process Excel</button>
    <button class="btn btn-outline-secondary" onclick="resetAll()">Reset</button>
    <div class="ms-auto text-end">
      <label class="form-label mb-0">Cutoff (EER)</label>
      <input id="cutoff" class="form-control small-input" type="number" step="0.01" value="0.9"/>
      <button class="btn btn-success btn-sm mt-2" onclick="applyCutoff()">Apply Cutoff</button>
    </div>
  </div>
</div>

<h5>1) Unified Facility Table</h5>
<div class="table-responsive mb-4">
  <table id="rawUnified" class="table table-bordered table-striped">
    <thead class="table-light sticky-th"></thead>
    <tbody></tbody>
  </table>
</div>

<h5>2) Facility Table with Totals (Labeled)</h5>
<div class="table-responsive mb-4">
  <table id="totalsTable" class="table table-bordered table-striped">
    <thead class="table-light sticky-th"></thead>
    <tbody></tbody>
  </table>
</div>

<h5>3) Monthly Totals & Averages</h5>
<div class="table-responsive mb-4">
  <table id="monthlyTable" class="table table-bordered table-striped">
    <thead class="table-light">
      <tr><th>Month</th><th>Total Energy (Y)</th><th>Total Production (X1)</th><th>Avg Weather1 (X2)</th><th>Avg Weather2 (X3)</th></tr>
    </thead>
    <tbody></tbody>
  </table>
</div>

<h5>4) Regression Statistics</h5>
<div class="table-responsive mb-4">
  <table class="table table-bordered table-striped" id="regressionStats">
    <thead class="table-light"><tr><th>Parameter</th><th>Coefficient</th><th>Std Error</th><th>HDI 2.5%</th><th>HDI 97.5%</th></tr></thead>
    <tbody></tbody>
  </table>
  <p id="r2Text" class="mt-2"></p>
</div>

<h5>5) Facilities Above Cutoff — Old & New EUI</h5>
<div class="table-responsive mb-4">
  <table class="table table-bordered table-striped" id="cutoffTable">
    <thead class="table-light"><tr>
      <th>Facility</th><th>EER</th><th>Actual EUI</th><th>Predicted EUI</th>
      <th>Required New EUI</th><th>Possible Savings</th>
    </tr></thead>
    <tbody></tbody>
  </table>
</div>

<h5>6) EER Ogive</h5>
<canvas id="ogiveChart" height="100"></canvas>

<h5>7) Facility Credits Overview (All Facilities)</h5>
<canvas id="creditsChart" height="100"></canvas>

<h5>8) All Facilities — Possible Savings / Credits Table</h5>
<div class="table-responsive mb-4">
  <table class="table table-bordered table-striped" id="allCreditsTable">
    <thead class="table-light"><tr>
      <th>Facility</th><th>EER</th><th>Actual EUI</th><th>Predicted EUI</th><th>Possible Savings / Credits</th>
    </tr></thead>
    <tbody></tbody>
  </table>
</div>

<script>
// ---------------- Utility ----------------
function num(v){ const x = parseFloat(v); return Number.isFinite(x) ? x : 0; }
function mean(A){ return A.length ? A.reduce((a,b)=>a+b,0)/A.length : 0; }
function isMonthToken(s){
  // crude month / year detector
  return /\b(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)\b/i.test(s) || /\b\d{4}\b/.test(s);
}

// ---------------- Config / synonyms ----------------
const synonyms = {
  facility: ['facility','site','name','plant','company'],
  energy: ['energy','energy used','consumption','kwh','electricity','fuel','energy_consumption'],
  production: ['production','output','prod','production volume','units produced','throughput'],
  weather1: ['weather','temp','temperature','ambient temp','ambient_temperature','t1','w1'],
  weather2: ['weather2','humidity','humi','w2','t2','ambient humidity']
};

// fuzzy match helper
function containsAnyHeader(text, arr){
  if(!text) return false;
  const s = String(text).toLowerCase();
  return arr.some(k => s.indexOf(k) !== -1);
}

// ---------------- State ----------------
let unified={months:[],facilities:[],cols:{nMonths:24}};
let regression={beta:[],r2:0,se:[],hdi:[]};

// ---------------- Reset ----------------
function resetAll(){
  ['#rawUnified thead','#rawUnified tbody','#totalsTable thead','#totalsTable tbody','#monthlyTable tbody','#regressionStats tbody','#cutoffTable tbody','#allCreditsTable tbody','#r2Text'].forEach(s=>{
    const el = document.querySelector(s);
    if(el) el.innerHTML='';
  });
  unified={months:[],facilities:[],cols:{nMonths:24}};
  if(window.ogiveChartInstance) window.ogiveChartInstance.destroy();
  if(window.creditsChartInstance) window.creditsChartInstance.destroy();
}

// ---------------- Excel Processing & Auto-detect ----------------
function processExcel(){
  const file=document.getElementById('fileInput').files[0];
  if(!file){ alert('Choose Excel file'); return; }
  const reader=new FileReader();
  reader.onload = e => {
    const wb = XLSX.read(new Uint8Array(e.target.result), { type: 'array' });
    const sheet = wb.Sheets[wb.SheetNames[0]];
    const raw = XLSX.utils.sheet_to_json(sheet, { header:1, blankrows:false });
    if(!raw || raw.length < 2){ alert('Sheet too short'); return; }

    // try to find header row index (prefer first row with non-empty strings)
    let headerRowIndex = 0;
    for(let i=0;i<Math.min(3,raw.length);i++){
      const row = raw[i].filter(c=>c!==undefined && c!==null && String(c).toString().trim()!=='');
      if(row.length >= 2){ headerRowIndex = i; break; }
    }
    const header = (raw[headerRowIndex] || []).map(h => h === undefined || h === null ? '' : String(h).trim());
    const nCols = header.length;

    // classify columns by header tokens
    const energyCols = [], productionCols = [], w1Cols = [], w2Cols = [], facilityCols = [];

    for(let c=0;c<nCols;c++){
      const h = header[c].toLowerCase();
      if(containsAnyHeader(h, synonyms.facility)) facilityCols.push(c);
      if(containsAnyHeader(h, synonyms.energy)) energyCols.push(c);
      if(containsAnyHeader(h, synonyms.production)) productionCols.push(c);
      if(containsAnyHeader(h, synonyms.weather1)) w1Cols.push(c);
      if(containsAnyHeader(h, synonyms.weather2)) w2Cols.push(c);
    }

    // If month-labeled headers (e.g., "Energy Jan-2020"), we might detect many columns tagged energy/production
    // If we found none for a role, try fallback detection by scanning the header tokens for "jan"/year and mapping neighboring pattern groups:
    const monthIndicators = header.map(h => isMonthToken(h));

    // If nobody matched facility, assume first column is facility
    const facilityCol = facilityCols.length ? facilityCols[0] : 0;

    // Determine months by looking for the longest repeating group among detected roles or month tokens
    // Strategy:
    // 1) If any of energyCols/productionCols/w1Cols/w2Cols has length>1 -> use that length as candidate months
    // 2) Else if many header cells are monthTokens -> use continuous monthTokens length
    // 3) Else fallback to previous default 24
    let candidateCounts = [energyCols.length, productionCols.length, w1Cols.length, w2Cols.length].filter(v=>v>0);
    let nMonths = candidateCounts.length ? Math.max(...candidateCounts) : 0;

    if(nMonths === 0){
      // check consecutive month-labeled sequences
      let maxSeq=0, cur=0;
      for(let c=0;c<nCols;c++){
        if(monthIndicators[c]){ cur++; maxSeq = Math.max(maxSeq,cur); } else cur=0;
      }
      if(maxSeq >= 2) nMonths = maxSeq;
    }
    if(nMonths === 0) nMonths = 24; // fallback

    // Build ordered arrays of column indices for each role.
    // If we detected multiple (e.g., energyCols length == nMonths), sort them and use as-is.
    // Otherwise, attempt to find contiguous block that contains role name followed by month tokens or simply contiguous block of length nMonths.
    function buildRoleCols(detectedCols){
      if(detectedCols.length >= nMonths) {
        // sort and take first nMonths (preserve left->right temporal order)
        return detectedCols.slice().sort((a,b)=>a-b).slice(0,nMonths);
      }
      // attempt to find block: find index i where header[i] includes role keyword AND next nMonths-1 look like months or exist
      for(let i=0;i<nCols;i++){
        if(detectedCols.includes(i)) {
          // try contiguous rightwards
          const block = [];
          for(let k=0;k<nMonths && (i+k)<nCols;k++){
            block.push(i+k);
          }
          if(block.length === nMonths) return block;
        }
      }
      // try to find any contiguous block of length nMonths and return it (best-effort)
      for(let i=0;i<=nCols-nMonths;i++){
        const block = [];
        for(let k=0;k<nMonths;k++) block.push(i+k);
        // prefer blocks that have month tokens somewhere
        if(block.some(j=>monthIndicators[j])) return block;
      }
      // last resort: return an empty array
      return [];
    }

    const energyIdxs = buildRoleCols(energyCols);
    const prodIdxs   = buildRoleCols(productionCols);
    const w1Idxs     = buildRoleCols(w1Cols);
    const w2Idxs     = buildRoleCols(w2Cols);

    // If any of the main roles have empty mapping, try heuristic: if headers are simple (Facility, Energy, Production, W1, W2)
    // i.e., a narrow table where rows are months and columns are the five features, then we need to pivot reading:
    // We'll detect that when nCols <= 6 and raw.length > nMonths (rows are months).
    const isColumnPerFeatureLayout = (nCols <= 6 && raw.length > nMonths + headerRowIndex);

    // Now parse facilities. Two common wide formats:
    // A) Each facility is a row; monthly values across columns (the previous code's format)
    // B) Each facility is multiple-area: if multiple facility blocks stacked vertically — uncommon.
    // We'll implement A primarily (most common).
    const startRow = headerRowIndex + 1;
    const facilities = [];

    if(isColumnPerFeatureLayout){
      // Layout type B: columns are features and rows are months (NOT facilities). That is not the format you used earlier.
      // Here we cannot construct one facility per row: instead we attempt to detect facility names from a 'Facility' column and then compute totals per facility if rows contain facility id.
      // We'll try to read rows and group by 'facility' entries.
      const mapByFacility = {};
      for(let r=startRow;r<raw.length;r++){
        const row = raw[r] || [];
        const facName = (row[facilityCol] !== undefined && row[facilityCol] !== null) ? String(row[facilityCol]).trim() : `Row${r}`;
        const energy = energyIdxs[0] !== undefined ? num(row[energyIdxs[0]]) : (row[1] ? num(row[1]) : 0);
        const prod   = prodIdxs[0] !== undefined ? num(row[prodIdxs[0]]) : (row[2] ? num(row[2]) : 0);
        const w1     = w1Idxs[0] !== undefined ? num(row[w1Idxs[0]]) : (row[3] ? num(row[3]) : 0);
        const w2     = w2Idxs[0] !== undefined ? num(row[w2Idxs[0]]) : (row[4] ? num(row[4]) : 0);
        if(!mapByFacility[facName]) mapByFacility[facName] = { name: facName, monthly: [] };
        mapByFacility[facName].monthly.push({ energy, production: prod, w1, w2 });
      }
      for(const k of Object.keys(mapByFacility)) facilities.push(mapByFacility[k]);
      // months labels - create generated months if none
      const months = [];
      for(let i=0;i< (facilities[0]?.monthly?.length || nMonths); i++){
        months.push(`M${i+1}`);
      }
      unified.months = months;
    } else {
      // Most common: each facility is a row and monthly values are across many columns.
      // For each facility row, build monthly array by pulling values from energyIdxs/prodIdxs/w1Idxs/w2Idxs or by offsetting if needed.
      // If role arrays empty, we'll try to infer contiguous blocks by searching for header tokens (e.g., "Energy" then months).
      const effectiveNMonths = nMonths;
      // Ensure fallback arrays: if one of the role idx arrays is empty, attempt to shift using patterns:
      // If none of energy/prod/w1/w2 found as blocks, we try to interpret columns as repeating blocks: [Facility][block1...][block2...] etc.
      // We'll attempt to map by detecting header labels that include role name prefixes (like "Energy Jan", "Production Jan").
      for(let r=startRow, idxRow=1; r<raw.length; r++, idxRow++){
        const row = raw[r] || [];
        // skip entirely empty rows
        if(row.every(c => c===undefined || c===null || String(c).trim()==='')) continue;
        const name = (row[facilityCol] !== undefined && row[facilityCol] !== null && String(row[facilityCol]).trim()!=='') ? String(row[facilityCol]).trim() : `Facility ${idxRow}`;
        const monthly = [];
        for(let k=0;k<effectiveNMonths;k++){
          const energy = energyIdxs[k] !== undefined ? num(row[energyIdxs[k]]) : ( (energyIdxs.length && energyIdxs[0]!==undefined) ? num(row[energyIdxs[0]+k]) : 0 );
          const production = prodIdxs[k] !== undefined ? num(row[prodIdxs[k]]) : ( (prodIdxs.length && prodIdxs[0]!==undefined) ? num(row[prodIdxs[0]+k]) : 0 );
          const w1 = w1Idxs[k] !== undefined ? num(row[w1Idxs[k]]) : ( (w1Idxs.length && w1Idxs[0]!==undefined) ? num(row[w1Idxs[0]+k]) : 0 );
          const w2 = w2Idxs[k] !== undefined ? num(row[w2Idxs[k]]) : ( (w2Idxs.length && w2Idxs[0]!==undefined) ? num(row[w2Idxs[0]+k]) : 0 );
          monthly.push({ energy, production, w1, w2 });
        }
        facilities.push({ name, monthly });
      }
      // try to create months labels from headers if month tokens exist
      const months = [];
      // Try to build months by reading tokens from one of the role headers if they include month tokens
      const sourceHeaderArray = energyIdxs.length ? energyIdxs : (prodIdxs.length ? prodIdxs : (w1Idxs.length? w1Idxs : w2Idxs));
      for(let k=0;k<effectiveNMonths;k++){
        const col = sourceHeaderArray[k] !== undefined ? header[sourceHeaderArray[k]] : header[(sourceHeaderArray[0] || 0)+k];
        months.push(col ? String(col).trim() : `M${k+1}`);
      }
      unified.months = months;
    }

    unified.facilities = facilities;
    unified.cols.nMonths = unified.months.length || nMonths;

    if(unified.facilities.length === 0){ alert('No facilities detected or sheet layout unsupported.'); return; }

    buildUnifiedTable();
    buildTotalsTable();
    buildMonthlyTable();
    computeRegression();
    applyCutoff();
  };
  reader.readAsArrayBuffer(file);
}

// ---------------- Tables ----------------
function buildUnifiedTable(){
  const thead=document.querySelector('#rawUnified thead'), tbody=document.querySelector('#rawUnified tbody');
  thead.innerHTML=''; tbody.innerHTML='';
  const n = unified.cols.nMonths, months = unified.months;
  const tr1=document.createElement('tr');
  tr1.innerHTML = `<th rowspan="2">Facility</th><th colspan="${n}">Energy</th><th colspan="${n}">Production</th><th colspan="${n}">Weather1</th><th colspan="${n}">Weather2</th>`;
  thead.appendChild(tr1);
  const tr2=document.createElement('tr');
  ['','','',''].forEach(()=>{ months.forEach(m=> tr2.innerHTML += `<th>${m}</th>`); });
  thead.appendChild(tr2);

  unified.facilities.forEach(f=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${f.name}</td>`;
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.energy}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.production}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.w1}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.w2}</td>`);
    tbody.appendChild(tr);
  });
}

function buildTotalsTable(){
  const tbody=document.querySelector('#totalsTable tbody');
  const thead=document.querySelector('#totalsTable thead');
  tbody.innerHTML=''; thead.innerHTML='';
  const n=unified.cols.nMonths;
  const months=unified.months;

  // Header
  const tr1=document.createElement('tr');
  tr1.innerHTML=`<th rowspan="2">Facility</th>
                 <th colspan="${n}">Energy</th>
                 <th colspan="${n}">Production</th>
                 <th colspan="${n}">Weather1</th>
                 <th colspan="${n}">Weather2</th>`;
  thead.appendChild(tr1);

  const tr2=document.createElement('tr');
  ['Energy','Production','Weather1','Weather2'].forEach(()=>{ months.forEach(m=> { tr2.innerHTML += `<th>${m}</th>`; }); });
  thead.appendChild(tr2);

  // Compute sums
  const sumE = Array(n).fill(0), sumP = Array(n).fill(0), sumW1 = Array(n).fill(0), sumW2 = Array(n).fill(0);
  unified.facilities.forEach(f=>{
    f.monthly.forEach((m,k)=>{
      sumE[k] += m.energy; sumP[k] += m.production; sumW1[k] += m.w1; sumW2[k] += m.w2;
    });
  });

  // Facility rows
  unified.facilities.forEach(f=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${f.name}</td>`;
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.energy}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.production}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.w1}</td>`);
    f.monthly.forEach(m=> tr.innerHTML += `<td>${m.w2}</td>`);
    tbody.appendChild(tr);
  });

  // Totals row
  const trTotal = document.createElement('tr');
  trTotal.classList.add('totals-row');
  trTotal.innerHTML = `<td>Totals</td>`;
  sumE.forEach(v=> trTotal.innerHTML += `<td>${v.toFixed(2)}</td>`);
  sumP.forEach(v=> trTotal.innerHTML += `<td>${v.toFixed(2)}</td>`);
  sumW1.forEach(v=> trTotal.innerHTML += `<td>${v.toFixed(2)}</td>`);
  sumW2.forEach(v=> trTotal.innerHTML += `<td>${v.toFixed(2)}</td>`);
  tbody.appendChild(trTotal);
}

function buildMonthlyTable(){
  const tbody=document.querySelector('#monthlyTable tbody'); tbody.innerHTML='';
  const n=unified.cols.nMonths, months=unified.months;
  for(let k=0;k<n;k++){
    let sumE=0,sumP=0,sumW1=0,sumW2=0;
    unified.facilities.forEach(f=>{ const m=f.monthly[k]; if(m){ sumE+=m.energy; sumP+=m.production; sumW1+=m.w1; sumW2+=m.w2; }});
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${months[k]}</td><td>${sumE.toFixed(2)}</td><td>${sumP.toFixed(2)}</td><td>${(sumW1/unified.facilities.length).toFixed(2)}</td><td>${(sumW2/unified.facilities.length).toFixed(2)}</td>`;
    tbody.appendChild(tr);
  }
}

// ---------------- Linear Algebra Utilities (generic) ----------------
function transpose(m){ return m[0].map((_,i)=>m.map(r=>r[i])); }
function matMul(a,b){
  const ar=a.length, ac=a[0].length, br=b.length, bc=b[0].length;
  if(ac !== br) throw 'matMul shape mismatch';
  const res = Array(ar).fill(0).map(()=>Array(bc).fill(0));
  for(let i=0;i<ar;i++) for(let j=0;j<bc;j++) for(let k=0;k<ac;k++) res[i][j] += a[i][k]*b[k][j];
  return res;
}
function gaussJordanInverse(A){
  // returns inverse of square matrix A using Gauss-Jordan, or null if singular
  const n = A.length;
  // make augmented matrix [A | I]
  const M = Array(n).fill(0).map((_,i)=> Array(n*2).fill(0));
  for(let i=0;i<n;i++){
    for(let j=0;j<n;j++) M[i][j] = A[i][j];
    M[i][n+i] = 1;
  }
  // forward elimination / pivoting
  for(let i=0;i<n;i++){
    // find pivot
    let maxRow = i;
    for(let r=i+1;r<n;r++) if(Math.abs(M[r][i]) > Math.abs(M[maxRow][i])) maxRow = r;
    if(Math.abs(M[maxRow][i]) < 1e-12) return null; // singular
    // swap
    if(maxRow !== i) { const tmp = M[i]; M[i] = M[maxRow]; M[maxRow] = tmp; }
    // normalize row
    const pivot = M[i][i];
    for(let j=0;j<2*n;j++) M[i][j] /= pivot;
    // eliminate others
    for(let r=0;r<n;r++){
      if(r === i) continue;
      const factor = M[r][i];
      for(let j=0;j<2*n;j++) M[r][j] -= factor * M[i][j];
    }
  }
  // extract inverse
  const inv = Array(n).fill(0).map(()=>Array(n).fill(0));
  for(let i=0;i<n;i++) for(let j=0;j<n;j++) inv[i][j] = M[i][n+j];
  return inv;
}

// ---------------- Regression ----------------
function computeRegression(){
  const Y = [], X1 = [], X2 = [], X3 = [];
  unified.facilities.forEach(f=>{
    const totalE = f.monthly.reduce((s,m)=>s + (m?m.energy:0), 0);
    const totalP = f.monthly.reduce((s,m)=>s + (m?m.production:0), 0);
    const avgW1 = mean(f.monthly.map(m=> m?m.w1:0));
    const avgW2 = mean(f.monthly.map(m=> m?m.w2:0));
    Y.push(totalE); X1.push(totalP); X2.push(avgW1); X3.push(avgW2);
  });
  const n = Y.length;
  if(n < 3){ alert('Need at least 3 facilities (rows) for regression'); return; }

  // Build design matrix X (n x 4) with intercept
  const X = [];
  for(let i=0;i<n;i++) X.push([1, X1[i], X2[i], X3[i]]);
  const Xt = transpose(X);
  const XtX = matMul(Xt, X);
  const XtY = matMul(Xt, Y.map(v=>[v]));
  const invXtX = gaussJordanInverse(XtX);
  if(!invXtX){ alert('Regression matrix singular; cannot compute regression reliably.'); return; }
  const betaMat = matMul(invXtX, XtY); // 4 x 1
  regression.beta = betaMat.map(r=> r[0]);

  // residuals & sigma
  const residuals = Y.map((y,i)=>{
    const pred = regression.beta[0] + regression.beta[1]*X1[i] + regression.beta[2]*X2[i] + regression.beta[3]*X3[i];
    return y - pred;
  });
  const sigma = Math.sqrt(residuals.reduce((s,v)=>s+v*v,0)/(n - regression.beta.length));
  // standard errors = sqrt(diag(inv(X'X)))*sigma
  regression.se = regression.beta.map((b, idx) => {
    const se = Math.sqrt(Math.abs(invXtX[idx][idx])) * sigma;
    return se || 0;
  });
  regression.hdi = regression.beta.map((b, idx) => [b - 1.96*regression.se[idx], b + 1.96*regression.se[idx]]);

  // R^2
  const ymean = mean(Y);
  const ss_tot = Y.reduce((s,y)=> s + (y - ymean)*(y - ymean), 0);
  const ss_res = residuals.reduce((s,r)=> s + r*r, 0);
  regression.r2 = 1 - ss_res / ss_tot;

  // attach per-facility metrics
  unified.facilities.forEach((f,i)=>{
    const totalE = f.monthly.reduce((s,m)=>s + (m?m.energy:0), 0);
    const totalP = f.monthly.reduce((s,m)=>s + (m?m.production:0), 0);
    const avgW1 = mean(f.monthly.map(m=> m?m.w1:0));
    const avgW2 = mean(f.monthly.map(m=> m?m.w2:0));
    f.actual_eui = totalP > 0 ? totalE / totalP : 0;
    const predicted_total_energy = regression.beta[0] + regression.beta[1]*totalP + regression.beta[2]*avgW1 + regression.beta[3]*avgW2;
    f.predicted_eui = totalP > 0 ? predicted_total_energy / totalP : 0;
    f.eer = f.predicted_eui > 0 ? f.actual_eui / f.predicted_eui : 0;
    f.possible_savings = (f.eer - parseFloat(document.getElementById('cutoff')?.value || 0)) * totalP;
  });

  // render regression table
  const tbody = document.querySelector('#regressionStats tbody'); tbody.innerHTML = '';
  const params = ['Intercept','X1 (Production)','X2 (Weather1)','X3 (Weather2)'];
  for(let i=0;i<regression.beta.length;i++){
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${params[i] || ('b' + i)}</td><td>${(regression.beta[i]||0).toFixed(4)}</td><td>${(regression.se[i]||0).toFixed(4)}</td><td>${(regression.hdi[i] ? regression.hdi[i][0].toFixed(4) : '0.0000')}</td><td>${(regression.hdi[i] ? regression.hdi[i][1].toFixed(4) : '0.0000')}</td>`;
    tbody.appendChild(tr);
  }
  document.getElementById('r2Text').innerText = `R² ≈ ${regression.r2 ? regression.r2.toFixed(4) : 'N/A'}`;
}

// ---------------- Cutoff & Credits ----------------
function applyCutoff(){
  const cutoff=parseFloat(document.getElementById('cutoff').value);
  const tbody=document.querySelector('#cutoffTable tbody'); tbody.innerHTML='';

  unified.facilities.filter(f=>f.eer>cutoff).forEach(f=>{
    const newEUI = cutoff * f.predicted_eui;
    const totalP = f.monthly.reduce((s,m)=>s + (m?m.production:0),0);
    const savings = (f.actual_eui - newEUI) * totalP;
    const tr=document.createElement('tr');
    tr.innerHTML = `<td>${f.name}</td><td>${f.eer.toFixed(3)}</td><td>${f.actual_eui.toFixed(3)}</td><td>${f.predicted_eui.toFixed(3)}</td><td>${newEUI.toFixed(3)}</td><td>${savings.toFixed(2)}</td>`;
    tbody.appendChild(tr);
  });

  plotOgive(); plotCredits();
  const tbody2=document.querySelector('#allCreditsTable tbody'); tbody2.innerHTML='';
  unified.facilities.forEach(f=>{
    const tr=document.createElement('tr');
    tr.innerHTML=`<td>${f.name}</td><td>${(f.eer||0).toFixed(3)}</td><td>${(f.actual_eui||0).toFixed(3)}</td><td>${(f.predicted_eui||0).toFixed(3)}</td><td>${(f.possible_savings||0).toFixed(2)}</td>`;
    tbody2.appendChild(tr);
  });
}

// ---------------- Charts ----------------
function plotOgive(){
  const eers = unified.facilities.map(f=>f.eer || 0).sort((a,b)=>a-b);
  const cumFreq = eers.map((_,i)=> ((i+1)/eers.length*100).toFixed(2));
  const ctx=document.getElementById('ogiveChart').getContext('2d');
  if(window.ogiveChartInstance) window.ogiveChartInstance.destroy();
  window.ogiveChartInstance = new Chart(ctx,{
    type:'line',
    data:{
      labels: eers.map(v => v.toFixed(3)),
      datasets:[{
        label:'Cumulative % Frequency',
        data: cumFreq,
        fill:false,
        tension:0.3
      }]
    },
    options:{ responsive:true, scales:{ x:{title:{display:true,text:'EER Values'}}, y:{title:{display:true,text:'Cumulative %'},min:0,max:100}}}
  });
}

function plotCredits(){
  const ctx=document.getElementById('creditsChart').getContext('2d');
  if(window.creditsChartInstance) window.creditsChartInstance.destroy();
  window.creditsChartInstance=new Chart(ctx,{
    type:'bar',
    data:{
      labels:unified.facilities.map(f=>f.name),
      datasets:[{label:'Credits / Savings',data:unified.facilities.map(f=>f.possible_savings || 0)}]
    },
    options:{ responsive:true, scales:{ y:{title:{display:true,text:'Credits / Savings'}}}}
  });
}
</script>
</body>
</html>
